

// app/api/db/students/route.ts
import { connectToDB } from "@/lib/db/db";
import Student from "@/models/student.model";
import { NextResponse } from "next/server";
import mongoose from "mongoose";
import inquireModel from "@/models/inquire.model";
import { generateBulkCredentials, generateStudentCredentials } from "@/lib/utils/studentUtils";
import { TransactionalEmailsApi, TransactionalEmailsApiApiKeys } from "@getbrevo/brevo";
import { fallbackTemplates, getEmailTemplate, renderTemplate, validateTemplate } from "@/lib/utils/emailTemplate";

const WHATSAPP_TOKEN = process.env.WHATSAPP_TOKEN!;
const PHONE_NUMBER_ID = process.env.WHATSAPP_PHONE_NUMBER_ID!;

async function sendStudentCredentialsWhatsApp(student: {
  name: string;        // goes to {{1}}
  phone: string;       // must be in +92... format
  userId: string;   // goes to {{2}}
  educationMail: string; // goes to {{3}}
  password: string;    // goes to {{4}}
}) {
  try {
    const res = await fetch(
      `https://graph.facebook.com/v20.0/${PHONE_NUMBER_ID}/messages`,
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${WHATSAPP_TOKEN}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          messaging_product: "whatsapp",
          to: student.phone,
          type: "template",
          template: {
            name: "student_onboarded_2025", // ‚úÖ must match EXACT name in WhatsApp manager
            language: { code: "en" },       // use "en" if your template is approved in English
            components: [
              {
                type: "body",
                parameters: [
                  { type: "text", text: student.name },         // {{1}}
                  { type: "text", text: student.userId },    // {{2}}
                  { type: "text", text: student.educationMail },// {{3}}
                  { type: "text", text: student.password },     // {{4}}
                ],
              },
            ],
          },
        }),
      }
    );

    const data = await res.json();
    if (!res.ok) {
      console.warn("‚ö†Ô∏è Failed to send WhatsApp to", student.phone, data);
    } else {
      console.log("‚úÖ WhatsApp sent to", student.phone);
    }
  } catch (err: any) {
    console.warn("‚ö†Ô∏è WhatsApp error:", err.message);
  }
}





const REQUIRED_FIELDS = ["name", "userId", "educationMail", "password"];

 async function sendStudentCredentialsEmail(student: any) {
  try {
    const client = new TransactionalEmailsApi();
    client.setApiKey(
      TransactionalEmailsApiApiKeys.apiKey,
      process.env.BREVO_API_KEY!
    );

    // 1. Fetch DB template
    let dbTemplate = await getEmailTemplate("student_created");

    // 2. If missing or invalid, fallback
    if (!dbTemplate || !validateTemplate(dbTemplate.bodyHtml, REQUIRED_FIELDS)) {
      console.warn("‚ö†Ô∏è student_added template missing/invalid ‚Üí using fallback");
      dbTemplate = fallbackTemplates.student_added;
    }

    // 3. Render template with dynamic values
    const subject = renderTemplate(dbTemplate.subject, student);
    const htmlContent = renderTemplate(dbTemplate.bodyHtml, student);

    const emailData = {
      sender: { email: "oqa.official@gmail.com", name: "Online Quran Academy" },
      to: [{ email: student.email }],
      subject,
      htmlContent,
    };

    await client.sendTransacEmail(emailData);
    console.log("‚úÖ Student email sent successfully:", student.email);
  } catch (err: any) {
    console.warn(`‚ö†Ô∏è Failed to send email to ${student.email}:`, err?.response?.body || err);
  }
}

async function sendBulkStudentWhatsApps(students: any[]) {
  for (const student of students) {
    sendStudentCredentialsWhatsApp(student); // don‚Äôt await
  }
}



// ‚úÖ Bulk email sender
async function sendBulkStudentEmails(students: any[]) {
  for (const student of students) {
    sendStudentCredentialsEmail(student); // don't await to avoid blocking
  }
}




export async function POST(req: Request) {
  try {
    await connectToDB();
    const body = await req.json();

    // Utility to calculate due dates
    function getDueDates(preferredStartDate?: string) {
      if (!preferredStartDate) return { dueDate: null, extendedDueDate: null };

      const start = new Date(preferredStartDate);

      const dueDate = new Date(start);
      dueDate.setDate(start.getDate() + 5);

      const extendedDueDate = new Date(start);
      extendedDueDate.setDate(start.getDate() + 7);

      return { dueDate, extendedDueDate };
    }

    // üü¢ Case 1: Bulk insert
    if (body.students && Array.isArray(body.students)) {
      const { parentInquiry, students } = body;

      if (!parentInquiry || students.length === 0) {
        return NextResponse.json(
          { error: "parentInquiry and students[] are required" },
          { status: 400 }
        );
      }

      const autoGenerated = await generateBulkCredentials(students);

      const docs = students.map((s: any, idx: number) => ({
        parentInquiry: new mongoose.Types.ObjectId(parentInquiry),
        name: s.name,
        email: s.email,
        phone: s.phone,
        gender: s.gender,
        dateOfBirth: s.dateOfBirth ? new Date(s.dateOfBirth) : null,
        timezone: s.timezone,
        preferredStartDate: s.preferredStartDate || null,
        preferredStartTime: s.preferredStartTime,
        classDays: s.classDays,
        course: s.course || null,
        price: Number(s.price),
        status: "trial",
        trialClasses: { assigned: 3, completed: 0 },
        feeStatus: { paid: false },

        // auto-generated
        serialNumber: autoGenerated[idx].serialNumber,
        userId: autoGenerated[idx].userId,
        educationMail: autoGenerated[idx].educationMail,
        password: autoGenerated[idx].password,
      }));

      const created = await Student.insertMany(docs);

      // ‚úÖ Update ParentInquiry with dueDate based on the *first student‚Äôs* preferredStartDate
      const firstWithDate = students.find((s: any) => s.preferredStartDate);
      if (firstWithDate) {
        const { dueDate, extendedDueDate } = getDueDates(
          firstWithDate.preferredStartDate
        );

        await inquireModel.findByIdAndUpdate(parentInquiry, {
          dueDate,
          extendedDueDate,
        });
      }

      sendBulkStudentEmails(created);
      sendBulkStudentWhatsApps(created);

      return NextResponse.json(created, { status: 201 });
    }

    // üü¢ Case 2: Single student
    const {
      name,
      email,
      phone,
      gender,
      dateOfBirth,
      timezone,
      preferredStartDate,
      preferredStartTime,
      classDays,
      course,
      price,
      parentInquiry,
      password: incomingPassword,
    } = body;

    if (
      !name ||
      !email ||
      !phone ||
      !gender ||
      !timezone ||
      !price ||
      !dateOfBirth
    ) {
      return NextResponse.json(
        { error: "Required fields are missing" },
        { status: 400 }
      );
    }

    const { serialNumber, userId, educationMail, password } =
      await generateStudentCredentials(name, incomingPassword);

    const student = new Student({
      parentInquiry: new mongoose.Types.ObjectId(parentInquiry),
      name,
      email,
      phone,
      gender,
      dateOfBirth: new Date(dateOfBirth),
      timezone,
      preferredStartDate: preferredStartDate || null,
      preferredStartTime,
      classDays,
      course,
      price,
      status: "trial",
      trialClasses: { assigned: 3, completed: 0 },
      feeStatus: { paid: false },

      // auto-generated
      serialNumber,
      userId,
      educationMail,
      password,
    });

    await student.save();

    // ‚úÖ Update ParentInquiry with due dates
    if (preferredStartDate) {
      const { dueDate, extendedDueDate } = getDueDates(preferredStartDate);
      await inquireModel.findByIdAndUpdate(parentInquiry, {
        dueDate,
        extendedDueDate,
      });
    }

    sendStudentCredentialsEmail(student);
    sendStudentCredentialsWhatsApp(student); 

    return NextResponse.json(student, { status: 201 });
  } catch (error: any) {
    console.error("‚ùå Error in POST /api/db/students:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
























// ‚úÖ GET students (all or filtered by parentInquiry)
export async function GET(request: Request) {
  try {
    await connectToDB();

    // extract query param
    const { searchParams } = new URL(request.url);
    const inquireId = searchParams.get("inquire");

    let query = {};
    if (inquireId) {
      query = { parentInquiry: inquireId }; // filter by parentInquiry
    }

    const students = await Student.find(query)
      .populate("course", "title")
      .sort({ serialNumber: -1 });

    return NextResponse.json(students, { status: 200 });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}



// DELETE all students (Extremely Dangerous API || Should only be used within development)
// export async function DELETE() {
//   try {
//     await connectToDB();
//     const students = await Student.deleteMany({});
//     return NextResponse.json({ success: true, message: "All students deleted" });
//   } catch (error) {
//     console.error("Error deleting students:", error);
//     return NextResponse.json({ success: false, error: "Failed to delete students" }, { status: 500 });
//   }
// }
